# Лабораторна робота №8

## «Виправляємо ботлнеки і вчимося виносити код з проєкту» (To infinity and beyond)

**Мета роботи:** за результатами попереднього аналізу (ЛР7) визначити найбільш вразливий модуль системи, проаналізувати проблеми його дизайну, винести модуль в окрему бібліотеку та виконати рефакторинг під час переносу. Після цього — перевірити роботу системи, покрити винесену логіку юніт‑тестами та повторно виконати навантажувальне тестування.

---

## 1. Короткий опис системи

Проєкт — backend API на **NestJS** з доступом до **PostgreSQL** через **Prisma**. Для запуску БД використовується `docker-compose.yaml`, порт БД проброшено на **5430**, API — на **3000**.

---

## 2. Визначення вузького місця (bottleneck)

За результатами ЛР7 найбільш вразливою ділянкою є модуль **автентифікації** (реєстрація/логін), оскільки:

- виконує криптографічні операції (хешування/перевірка паролів), що інтенсивно використовують CPU;
- взаємодіє з БД для пошуку/створення користувача;
- є критичним для доступу до решти функціональності системи.

---

## 3. Проблеми дизайну модуля до рефакторингу

Типові проблеми, які створювали “зчеплення” та ускладнювали оптимізацію:

1. **Змішування доменної логіки та інфраструктури** (JWT, bcrypt, Prisma в одному сервісі).
2. Складність ізольованого тестування (потрібно піднімати БД або важко мокати залежності).
3. Складність подальшої заміни реалізацій (інший ORM, інший токен‑провайдер, інший алгоритм хешування).

---

## 4. Винесення модуля в окрему бібліотеку

Було виділено окрему бібліотеку (пакет) `auth-lib` на TypeScript, у яку перенесено доменну логіку авторизації:

- **AuthCore**: реалізує сценарії `register` та `login`
- **Порти (інтерфейси)** для доступу до ресурсів:
  - `UserRepository` (доступ до користувачів/БД)
  - `PasswordHasher` (хешування/перевірка паролів)
  - `TokenService` (випуск токенів)

Інфраструктурні залежності (Prisma/JWT/bcrypt) не використовуються напряму — вони підставляються у вигляді реалізацій цих інтерфейсів (адаптерів) при ініціалізації.

### 4.1. Інʼєкція залежностей

У основному застосунку створено провайдер `AUTH_CORE` (через DI NestJS), який ініціалізує `AuthCore` з конкретними адаптерами.

---

## 5. Рефакторинг під час переносу

Під час переносу виконано:

- нормалізацію структури повертаємого результату: `{ user, tokens }` у ядрі та формування HTTP‑відповіді в сервісі/контролері;
- типізацію параметрів TTL JWT без `any` (через `JwtSignOptions['expiresIn']` та валідацію env‑значень);
- винесення параметрів конфігурації в `.env` / `.env.example`:
  - `JWT_ACCESS_TTL`, `JWT_REFRESH_TTL`, `BCRYPT_ROUNDS`.

---

## 6. Тестування винесеної логіки

### 6.1. Юніт‑тести бібліотеки

Для `AuthCore` написано юніт‑тести, які:

- не потребують БД;
- використовують моки портів (`UserRepository`, `PasswordHasher`, `TokenService`);
- перевіряють сценарії успіху/помилок (конфлікт користувача, невалідні креденшали).

### 6.2. Тести інтеграції сервісу

Тести `AuthService` оновлено під новий контракт (сервіс делегує бізнес‑логіку в `AuthCore` через `AUTH_CORE`), та перевіряється формування відповіді/обробка помилок.

---

## 7. Повторне навантажувальне тестування (після рефакторингу)

Навантаження виконувалося k6‑скриптом з каталогу `load-tests/`.

**Команда запуску (приклад):**

```bash
API_URL=http://localhost:3000 k6 run load-tests/k6-load-test.js \
  --summary-export artifacts/k6-summary.json | tee artifacts/k6-output.txt
```

### 7.1. Ключові метрики k6

За `artifacts/k6-summary.json` отримано:

- **Кількість HTTP‑запитів:** 13944
- **Середня швидкість запитів:** 65.31 req/s
- **http_req_duration:** avg=10.21ms, p90=55.83ms, p95=72.47ms, max=114.36ms
- **http_req_failed:** 12.40% (12215 fails / 1729 passes)

> Примітка: якщо у сценарії навантаження виконується реєстрація з повторюваними даними, частина відповідей може бути 409/4xx, що збільшує `http_req_failed`. Для більш “реалістичного” навантаження рекомендовано: створювати користувача в `setup()` та далі тестувати переважно `login` і типові авторизовані ендпоінти.

---

## 8. CPU/RAM профілювання та аналіз БД

### 8.1. CPU профайл

API запускалося з CPU‑профайлером Node.js (`--cpu-prof`) з подальшим аналізом у Chrome DevTools.

У зібраному профайлі найбільший вклад у час виконання дають:

- middleware/маршрутизація (Express/NestJS),
- виконання запитів Prisma,
- криптографічні операції (хешування/перевірка паролів) — як CPU‑інтенсивна частина auth‑сценаріїв.

### 8.2. Аналіз запитів до БД

Для аналізу БД використано `pg_stat_statements` (підключено через `shared_preload_libraries` у `docker-compose.yaml`). Топ‑запити збережено у `artifacts/db-top-queries.txt`.

---

## 9. Висновки

У результаті виконання ЛР8:

- визначено bottleneck‑модуль (auth) та проблеми його дизайну;
- винесено доменну логіку в окрему бібліотеку `auth-lib` з чіткими портами/адаптерами;
- виконано рефакторинг та параметризацію через env‑змінні;
- додано юніт‑тести на винесене ядро та оновлено тести сервісу;
- повторно виконано навантажувальне тестування та зібрано артефакти (k6, CPU‑profile, top‑queries БД) для порівняння та подальшої оптимізації.
